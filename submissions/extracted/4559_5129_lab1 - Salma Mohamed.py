# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r13x3Kfg3RQ_QJc4T2jLEmVhOaH3QG6p
"""
import socket
import sys
import os
import os.path
import enum
import struct


client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
Index_data_buffer = 0
last_packet_flag = 0
last_ACK_flag = 0
data_buffer_to_File = []
file_name_global = ""
last_packet_sent = ""
File_Exist = 0
File_Not_Found = 0
Error_Flag = 0
class TftpProcessor(object):
    

    class TftpPacketType(enum.Enum):
        """
        Represents a TFTP packet type add the missing types here and
        modify the existing values as necessary.
        """
        RRQ = 1
        WRQ = 2 
        DATA = 3
        ACK = 4
        ERROR = 5

    def __init__(self):
        """
        Add and initialize the *internal* fields you need.
        Do NOT change the arguments passed to this function.

        Here's an example of what you can do inside this function.
        """
        self.packet_buffer = []
        self.data_buffer = []
        self.last_data_packet = ''
        pass

    def process_udp_packet(self, packet_data, packet_source):
        """
        Parse the input packet, execute your logic according to that packet.
        packet data is a bytearray, packet source contains the address
        information of the sender.
        """
        # Add your logic here, after your logic is done,
        # add the packet to be sent to self.packet_buffer
        # feel free to remove this line
        #global last_packet_sent
        #print(f"Received a packet from {packet_source}")
        in_packet = self._parse_udp_packet(packet_data)
        #print()
        #while(len(self.data_buffer) != 0):
        #print("self.data_buffer: " , self.data_buffer)
        out_packet = self._do_some_logic(in_packet)
        #print("abl elif===========================================")
        #print("in_packet: ", in_packet)
        #print("out_packet: ", out_packet)
        if isinstance(out_packet, list): # data_buffer
          #print("gowa elif===========================================")
          self.packet_buffer = self.packet_buffer + out_packet
          #print("self.packet_buffer bta3et elif: ",self.packet_buffer)
        else:
          self.packet_buffer.append(out_packet)
          #print("self.packet_buffer bta3et else: ",self.packet_buffer)
        #print("self.packet_buffer", self.packet_buffer)
        # This shouldn't change.
        #self.packet_buffer.append(out_packet)
        #print("out_packet" , out_packet)
        #print("self.packet_buffer.append(out_packet)", self.packet_buffer.append(out_packet))
        #self.packet_buffer.append(out_packet)
        #print("self.packet_buffer", self.packet_buffer)
        #print("In process UDP:")
        #print("self.packet_buffer:", self.packet_buffer)
    def _parse_udp_packet(self, packet_bytes):
        """
        You'll use the struct module here to determine
        the type of the packet and extract other available
        information.
        """
        opcode_binary = packet_bytes[:2]
        #opcode_binary = packet_bytes
        #print("opcode_binary")
        #print(opcode_binary)
        opcode_array = struct.unpack('>h', opcode_binary) #""" short bec opcode is 2 bytes """
        opcode = opcode_array[0]
        #print(opcode)		
        packet_info_bytes = packet_bytes[-(len(packet_bytes)-2):]
        #print("packet_info_bytes")
        #print(packet_info_bytes)
        if opcode == 1:    #""" read request """ # generate error msg
          #print("RRQ")
          file_name_bytes = packet_info_bytes[:(packet_info_bytes - 7)]
          file_name = struct.unpack("%ds" % (len( file_name_bytes )), file_name_bytes )
          return ["RRQ" ,  file_name ]
        elif opcode == 2:  #""" write request """
          #print("WRQ")
          file_name_bytes = packet_info_bytes[:(packet_info_bytes - 7)]
          file_name = struct.unpack("%ds" % (len( file_name_bytes )), file_name_bytes )
          return ["WRQ" ,  file_name ]
        elif opcode == 3:  #""" Data  """    """ note 512 """
          #print("Data packet")
          block_num_bytes = packet_info_bytes[:2]
          #print(block_num_bytes)
          block_num_array = struct.unpack('>h',block_num_bytes)
          block_num = block_num_array[0]
          #print("block_num")
          #print(block_num)
          data_bytes = packet_info_bytes[-(len(packet_info_bytes) - 2):]
          #print("data_bytes")
          #print(data_bytes)
          data_array = struct.unpack("%ds" % (len( data_bytes)), data_bytes)
          #print("data_array")
          #print(data_array)
          #print("data")
          data = data_array[0]
          #print(data.decode('ascii'))
          return ["DATA", block_num, data.decode('ascii')]
        elif opcode == 4:  #""" ACK """
          #print("ACK packet")
          block_num =  struct.unpack('h',packet_info_bytes) 
          return ["ACK", block_num]
        elif opcode == 5:   # """ Error """
          print("Error")
          Error_code_bytes = packet_info_bytes[:2]
          Error_code_tup = struct.unpack('>h',Error_code_bytes)
          Error_code = Error_code_tup[0]
          print("ERROR_CODE: ", Error_code)
          error_msg_bytes = packet_info_bytes[2:(len(packet_info_bytes) - 1)]
          #print(error_msg_bytes)
          #print("ABL elif error:::::::::::::::::::::::::::::::::::")
          if(Error_code == 0):
            print("Not defined")
           # """ terminate """
            #sys.exit()
          elif(Error_code == 1):
            #print("Gowa elif error:::::::::::::::::::::::::::::::::::")
            print("File Not found")
            """ terminate """
            #sys.exit()
          elif(Error_code == 2):
            print("Access violation")
            """ terminate """
            #sys.exit()
          elif(Error_code == 3):
            print("Disk full or allocation exceeded")
            """ terminate """
            #sys.exit()
          elif(Error_code == 4):
            print("Illegeal TFTP operation")
            """ terminate """
            #sys.exit()
          elif(Error_code == 5):
            print("Unknown transfer ID")
            """Dont terminate """
            print("ERROR: send packet again")
            #return last_packet_sent
          elif (Error_code == 6):
            print("File already exists")
            """ terminate """
            #sys.exit() 
          elif(Error_code == 7):
            print("No such user")
            """ terminate """
            #sys.exit()      
        else:
          print("////////////////////WRONG OPCODE\\\\\\\\\\\\\\\\\\\\")	
        return ["Error", Error_code]
        pass

    def _do_some_logic(self, input_packet):
        """
        Example of a private function that does some logic.
        """
        """if data send ACK"""
        global Error_Flag
        type_of_packet = input_packet[0]
        #print("input_packet[1]:", input_packet[1])
        #print("type_of_packet")
        #print(type_of_packet)
        if(type_of_packet == "DATA"): #"""" send ACK"""
          opcode = 4
          block_num = input_packet[1]
          opcode_bytes = struct.pack('>h', opcode)
          block_num_bytes = struct.pack('>h', block_num)
          out_packet = opcode_bytes + block_num_bytes
          #print("out_packet")
          #print(out_packet)
          return out_packet
        elif(type_of_packet == "ACK"): #"""" send data"""  
          #opcode = 3
          #print("gow elif ")
          #print(input_packet)
          #print("input_packet[1]:", input_packet[1])
          #block_num_tup = input_packet[1]
          #block_num = block_num_tup[0]
          #block_num = block_num + 1
          #print("block_num ")
          #block_num = input_packet[1] + 1
          #"""data = get from file call function upload"""
          #opcode_bytes = struct.pack('>h', opcode)
          #block_num_bytes = struct.pack('>h', block_num)
          #read_data_packets(opcode_bytes)
          #print("data " , data)
          #data_bytes = struct.pack('%ds' % (len(data)), data) # data to be taken from test.txt file as 512 bytes 
          #out_packet = opcode_bytes + block_num_bytes + data
          #return data
          #return data_bytes
          #return out_packet
          #global Index_data_buffer
          #self.data_buffer = self.read_data_packets()
          self.read_data_packets()
          #print("Index: ", Index_data_buffer)
          #print("self.data_buffer ", self.data_buffer)
          #data_to_send = data_buffer[Index_data_buffer]
          #data_to_send = self.data_buffer.pop(Index_data_buffer)
          #print("data_to_send: " ,data_to_send)
          #Index_data_buffer += 1
          #return data_to_send
          #return self.read_data_packets()
          return self.data_buffer
        elif (type_of_packet == "RRQ" or type_of_packet == "WRQ"):
          opcode = b'\x00\x05'
          errorCode = b'\x00\x04'
          error_msg = "Illegal TFTP operation"
          error_msg_bytes = bytearray(error_msg,'ascii')
          #print("error_msg: ", error_msg)
          return opcode + errorCode + error_msg_bytes
        elif (type_of_packet == "Error"):
          #return self.packet_buffer.pop(0)  #"""send last packet again"""
          # send ACK packet
          opcode = b'\x00\x04'
          Error_Flag = 1
          errorCode = input_packet[1]
          error_Code_bytes = struct.pack('>h',errorCode)
          #print("Error_code$$$$$$$$$$$$$$$$$$$$$$$$$$$",error_Code_bytes)
          if(errorCode == 5):
            return last_packet_sent
          else:
            return opcode + error_Code_bytes
        pass

    def get_next_output_packet(self):
        #print("In get_next_output_packet method")
        #print(self.packet_buffer.pop(0))
        global last_packet_sent
        last_packet_sent = self.packet_buffer.pop(0)
        return last_packet_sent
    def read_data_packets(self):
        Max_size = 512
        chunk_data = ''
        block_num = 0
        tftp = TftpProcessor()
        #data_buffer = []
        #test_file = "test.txt"
        global last_packet_flag
        global file_name_global
        test_file = file_name_global
        with open(test_file, 'rb') as infile:
            while True:
                chunk_data = infile.read(Max_size)
                #print("chunk_data: ", chunk_data)
                if not chunk_data:
                  break
                opcode_bytes = b'\x00\x03'
                block_num += 1
                block_num_bytes = struct.pack('>h', block_num)
                #print("block_num_bytes ", block_num_bytes)
                data_packet_bytes = opcode_bytes + block_num_bytes + chunk_data
                #print("data_packet_bytes: ",data_packet_bytes)
                #self.packet_buffer.append(data_packet_bytes)
                self.data_buffer.append(data_packet_bytes)
                #print("data_buffer" , data_buffer)
                #print("tftp.get_next_output_packet() " , tftp.get_next_output_packet())
                #output = chunk_data
                if(len(chunk_data) < 512):
                  # return data_packet_bytes
                  #data_packet_bytes = opcode_bytes + block_num_bytes + chunk_data
                  #print("last packet")
                  last_packet_flag = 1
                  #data_buffer.append(data_packet_bytes)
                  #return
                  break 
        infile.close()
        block_num = 0
        #print("data_packet_bytes: ", data_packet_bytes)
        #return data_packet_bytes
        #print("data_buffer: ", data_buffer)
        #return self.data_buffer
        #return tftp.packet_buffer
        pass
    def write_data_packets(self, packet_buffer):
        global File_Exist
        tftp = TftpProcessor()
        index = 0
        #test_file = "testWrite.txt"
        global file_name_global
        #test_file = file_name_global[:len(file_name_global) - 4] + "Write.txt"
        test_file = file_name_global
        print("==========================================================")
        #packet_data = packet_to_process[-(len(packet_to_process)-2):]
        #print("packet_info_bytes")
        #print(packet_data)
        with open(test_file, 'wb') as infile:
            while index < len(packet_buffer):
                infile.write(packet_buffer[index])
                index += 1
                #print("@@@@@@@@@@@@@@@@@@@@@@@")
                #print("Chunk_data: ", chunk_data)
        infile.close()
        pass
    def has_pending_packets_to_be_sent(self):

        return len(self.packet_buffer) != 0

    def request_file(self, file_path_on_server): 
        """  for download   (form packets of RRQ)
        This method is only valid if you're implementing     
        a TFTP client, since the client requests or uploads
        a file to/from a server, one of the inputs the client
        accept is the file name. Remove this function if you're
        implementing a server.
        """
        #print("gowa request_file___________________________________________________________")
        global File_Exist
        file_name = file_path_on_server
        if os.path.isfile(file_name):
          print ("File exist(((((((((((((((((((((((((((((((((((((((" ,file_name)
          File_Exist = 1
          opcode = b'\x00\x05'
          errorcode = b'\x00\x06'
          error_msg = bytearray("File already exists",'ascii')
          last_byte = b'\x00'
          error_packet = opcode + errorcode + error_msg + last_byte 
          return error_packet
        else:
          print ("File not exist(((((((((((((((((((((((((((((((((((((((" ,file_name)
          opcode = b'\x00\x01'		
          file_name = file_path_on_server
          file_name_bytes = bytearray(file_name,'ascii')
          mode = "octet"
          mode_bytes = bytearray(mode,'ascii')
          byte = 0
          #print(byte)		
          #WRQ_packet_bytes = opcode + file_name_bytes + byte + mode_bytes + byte
          #print(WRQ_packet_bytes)		
          #byte_bytes = bytearray(byte,'ascii')
          RRQ_packet_bytes = struct.pack('%dsB%dsB' %(len(file_name_bytes),len(mode_bytes),),file_name_bytes,byte,mode_bytes,byte)
          RRQ_packet_bytes = opcode + RRQ_packet_bytes		
          #WRQ_packet_bytes = struct.pack('h%dsc%dsc' %(len(file_name_bytes),len(mode_bytes),),opcode,file_name_bytes,'0',mode_bytes,'0')		
          #print(struct.unpack('h%dsB%dsB' %(len(file_name_bytes),len(mode_bytes),),RRQ_packet_bytes))
          #print(RRQ_packet_bytes)		
          return RRQ_packet_bytes
        pass
    def upload_file(self, file_path_on_server):
        """        for upload  (form packets of WRQ)
        This method is only valid if you're implementing
        a TFTP client, since the client requests or uploads
        a file to/from a server, one of the inputs the client
        accept is the file name. Remove this function if you're
        implementing a server.
        """
        # create WRQ packet
        #opcode = b'\x01\x00'
        global File_Not_Found 		
        file_name = file_path_on_server
        if not os.path.isfile(file_name):
          print ("File not exist(((((((((((((((((((((((((((((((((((((((" ,file_name)
          File_Not_Found = 1
          opcode = b'\x00\x05'
          errorcode = b'\x00\x01'
          error_msg = bytearray("File not found",'ascii')
          last_byte = b'\x00'
          error_packet = opcode + errorcode + error_msg + last_byte 
          return error_packet
        else:
          print ("File exists El7amdullellah(((((((((((((((((((((((((((((((((((((((" ,file_name)
          opcode = b'\x00\x02'
          file_name_bytes = bytearray(file_name,'ascii')
          mode = "octet"
          mode_bytes = bytearray(mode,'ascii')
          byte = 0
          #print(byte)		
          #WRQ_packet_bytes = opcode + file_name_bytes + byte + mode_bytes + byte
          #print(WRQ_packet_bytes)		
          #byte_bytes = bytearray(byte,'ascii')
          WRQ_packet_bytes = struct.pack('%dsB%dsB' %(len(file_name_bytes),len(mode_bytes),),file_name_bytes,byte,mode_bytes,byte)
          WRQ_packet_bytes = opcode + WRQ_packet_bytes		
          #WRQ_packet_bytes = struct.pack('h%dsc%dsc' %(len(file_name_bytes),len(mode_bytes),),opcode,file_name_bytes,'0',mode_bytes,'0')		
          #print(struct.unpack('h%dsB%dsB' %(len(file_name_bytes),len(mode_bytes),),WRQ_packet_bytes))
          #print(WRQ_packet_bytes)		
          return WRQ_packet_bytes
        pass


def check_file_name():
    script_name = os.path.basename(__file__)
    import re
    matches = re.findall(r"(\d{4}_)+lab1\.(py|rar|zip)", script_name)
    if not matches:
        print(f"[WARN] File name is invalid [{script_name}]")
    pass


def setup_sockets(address):
    """
    Socket logic MUST NOT be written in the TftpProcessor
    class. It knows nothing about the sockets.

    Feel free to delete this function.
    """
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #return client_socket
    #do_socket_logic()
    
    pass

#client_socket = socket(AF_INET, SOCK_DGRAM)
def do_socket_logic(packet_bytes , ip_address):
    """
    Example function for some helper logic, in case you
    want to be tidy and avoid stuffing the main function.
    Feel free to delete this function.
    """
    global client_socket
    #client_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    #socket_address = ('localhost' , 69)
    tftp = TftpProcessor()
    print("IP Address: ",ip_address)
    try:
      print('Succeded')	
      #sent = client_socket.sendto(packet_bytes,socket_address)
      sent = client_socket.sendto(packet_bytes,ip_address)
      print("ip_address:",ip_address)
      if(File_Exist == 1):
        print("File already exists")
        sys.exit()
      if(File_Not_Found == 1):
        print("File not Found")
        sys.exit()
      if(Error_Flag == 1):
        sys.exit() 	  
      if(last_ACK_flag == 0):
        server_packet_data, server_packet_address = client_socket.recvfrom(1024)
        #print('data received {!r}'.format(server_packet_data))
        return [server_packet_data, server_packet_address]
      else:
        tftp.write_data_packets(data_buffer_to_File)
        sys.exit()
      #socket_address = server_packet_address
    finally:
      print('Done:)))))))))))))))')
      #if not tftp.has_pending_packets_to_be_sent():
        #print("gowa socket.close()+++++++++++++++++++++++++++++++++++++++++++++")
        #sys.exit()		
        #client_socket.close()
    #return [server_packet_data, server_packet_address]
    pass	
def parse_user_input(address, operation, file_name=None):
    # Your socket logic can go here,
    # you can surely add new functions
    # to contain the socket code. 
    # But don't add socket code in the TftpProcessor class.
    # Feel free to delete this code as long as the
    # functionality is preserved.
    #server_address = (address, 69)
	tftp = TftpProcessor()
	socket_address = ('localhost' , 69)
	print('operation is '+ operation)
	#tftp = TftpProcessor()
	global last_ACK_flag
	global data_buffer_to_File
	if operation == 'push':
	  print(f"Attempting to upload [{file_name}]...")
	  tftp_packet = tftp.upload_file(file_name)
	  #tftp.read_data_packets()
	  packet_to_process = do_socket_logic(tftp_packet,socket_address)
	  tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	  #print('data received {!r}'.format(packet_to_process))
	  #tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	  #print("tftp.get_next_output_packet")
	  #next_output_packet = tftp.get_next_output_packet()
	  while(tftp.has_pending_packets_to_be_sent()):
	      next_output_packet = tftp.get_next_output_packet()
	      #print("next_output_packet" , next_output_packet)
	      packet_to_process = do_socket_logic(next_output_packet,packet_to_process[1])
	  #print("")
	  #print('data received {!r}'.format(packet_to_process[0]))	  
	  #do_socket_logic(tftp_packet)
	  pass
	elif operation == 'pull':
	  #print(f"Attempting to download [{file_name}]...")
	  #tftp_packet = tftp.request_file(file_name)
	  #packet_to_process = do_socket_logic(tftp_packet, socket_address)
	  #print('data received {!r}'.format(packet_to_process[0]))
	  #tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	  #print("tftp.get_next_output_packet")
	  #next_output_packet = tftp.get_next_output_packet()
	  #print(next_output_packet)
	  #while(tftp.has_pending_packets_to_be_sent()):
	      #next_output_packet = tftp.get_next_output_packet()
	      #print("next_output_packet" , next_output_packet)
	      #packet_to_process = do_socket_logic(next_output_packet,packet_to_process[1])
	  #print("")
	  #print('data received {!r}'.format(packet_to_process[0])
	  #packet_to_process = do_socket_logic(next_output_packet,packet_to_process[1])
	  #print("")
	  #print('data received {!r}'.format(packet_to_process[0]))
	  #pass
	  print(f"Attempting to downlaod [{file_name}]...")
	  tftp_packet = tftp.request_file(file_name)
	  #tftp.read_data_packets()
	  packet_to_process = do_socket_logic(tftp_packet,socket_address)
	  tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	  #print("Ay haga |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||")
	  #print('data received {!r}'.format(packet_to_process))
	  #tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	  #print("tftp.get_next_output_packet")
	  #next_output_packet = tftp.get_next_output_packet()
	  #print("size of data packet: ", len(packet_to_process[0]))
	  packet_data_bytes = packet_to_process[0][-(len(packet_to_process[0])-4):]
	  #print("packet_data_bytes: ]]]]]]]]]]]]] , ", packet_data_bytes)
	  data_buffer_to_File.append(packet_data_bytes)
	  while True:
      #while True:
	      #print("infinite loop }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}")
	      if(len(packet_to_process[0])<516):
	        next_output_packet = tftp.get_next_output_packet()
	        #print("next_output_packet" , next_output_packet)
	        last_ACK_flag = 1
	        packet_to_process = do_socket_logic(next_output_packet,packet_to_process[1])
	        #tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	        #print("packet_to_process[0] {{{{{{{{{{{{{{{" , packet_to_process[0])
	        #print("Size of data packet:}}}}}}}}}}}}}", len(packet_to_process[0]))
	        packet_data_bytes = packet_to_process[0][-(len(packet_to_process[0])-4):]
	        #tftp.write_data_packets(packet_to_process[0])
	        #print("packet_data_bytes: ]]]]]]]]]]]]] , ", packet_data_bytes)
	        data_buffer_to_File.append(packet_data_bytes)
	        break
	      else:
	        next_output_packet = tftp.get_next_output_packet()
	        #print("next_output_packet" , next_output_packet)
	        packet_to_process = do_socket_logic(next_output_packet,packet_to_process[1])
	        tftp.process_udp_packet(packet_to_process[0], packet_to_process[1])
	        #print("packet_to_process[0] %%%%%%%%%%%%%%%" , packet_to_process[0])
	        #print("Size of data packet:#############" , len(packet_to_process[0]))
	        packet_data_bytes = packet_to_process[0][-(len(packet_to_process[0])-4):]
	        #print("packet_data_bytes: ]]]]]]]]]]]]] , ", packet_data_bytes)
	        data_buffer_to_File.append(packet_data_bytes)
	  #tftp.write_data_packets(data_buffer_to_File)
	        #tftp.write_data_packets(packet_to_process[0])
	  #print("")
	  #print('data received {!r}'.format(packet_to_process[0]))	  
	  #do_socket_logic(tftp_packet)
	  pass
	
def get_arg(param_index, default=None):
    """
        Gets a command line argument by index (note: index starts from 1)
        If the argument is not supplies, it tries to use a default value.

        If a default value isn't supplied, an error message is printed
        and terminates the program.
    """
    try:
        return sys.argv[param_index]
    except IndexError as e:
        if default:
            return default
        else:
            print(e)
            print(
                f"[FATAL] The comamnd-line argument #[{param_index}] is missing")
            exit(-1)    # Program execution failed.

def main():
	"""
	Write your code above this function.
	 if you need the command line arguments
	"""
	print("*" * 50)
	print("[LOG] Printing command line arguments\n", ",".join(sys.argv))
	check_file_name()
	print("*" * 50)
	# This argument is required.
	# For a server, this means the IP that the server socket
	# will use.
	# The IP of the server, some default values
	# are provided. Feel free to modify them.
	ip_address = get_arg(1, "127.0.0.1")
	operation = get_arg(2, "pull")
	global file_name_global 
	file_name_global = get_arg(3, "test.txt")
	#file_name = get_arg(3, "test.txt")
	# Modify this as needed.
	#client_socket = setup_sockets(ip_address)
	print("IP address: " , ip_address)
	parse_user_input(ip_address,operation,file_name_global)
	
if __name__ == "__main__":
    main()

